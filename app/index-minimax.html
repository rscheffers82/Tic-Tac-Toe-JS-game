


<html>
  <head>
    <script>


// helpful one:
// http://www.hamedahmadi.com/gametree/
// https://jsfiddle.net/carlosmachina/yt91jr2a/4/         -- working NegaMax

//http://codereview.stackexchange.com/questions/81988/minimax-for-tic-tac-toe
//http://www.code2learn.com/2012/01/minimax-algorithm-tutorial.html
//https://chessprogramming.wikispaces.com/Negamax
//http://stackoverflow.com/questions/36026215/javascript-negamax-tictactoe-implementation-working-only-on-some-plays

// https://en.wikipedia.org/wiki/Negamax
// http://chrisjordan8l.blogspot.ca/2015/01/tictactoe-subtle-difference-between.html

// Minimax object

var MiniMax = function(){
  //init values and options
  this.bestMove = 0;
  this.MAX_DEPTH = 6;
}

MiniMax.prototype = {
  //function called from game, bestmove will return the computer move
  buildTree: function(board, player, cb){
    this.bestMove = 0;
    var alpha = this.buildTree_r(board, player, 0);
    cb(this.bestMove);
  },
  //recursive function to build minimax tree and rate the value of the board
  buildTree_r: function(board, currPlayer, depth){
    if(depth > this.MAX_DEPTH){
      return 0;
    }
    //Set the otherplayer for the next game state and to check for loss
    var otherPlayer;
    if(currPlayer == board.X){
      otherPlayer = board.O;
    } else {
      otherPlayer = board.X;
    }
    //check for a winner in the boardstate, if currPlayer we win, else we lose in this tree
    var winner = board.getWinner();
    if(winner == currPlayer){
      return 1;
    } else if(winner == otherPlayer){
      return -1;
    }
    //check for a full board and therefore cats game in this true
    if(board.isFull()){
      return 0;
    }
    //this is where we begin to rank moves, get an array of moves, set alpha low, instantiate parallel
    //subAlpha list  to movelist to remember move ranks
    var moveList = board.getMoves();
    var alpha = -1;
    var saList = [];
    for(var i=0; i<moveList.length; i++){

      var boardCopy = board.copy(); //Copy current gamestate
      boardCopy.move(currPlayer, moveList[i]); //Make a move for in the gamestate for each possible move
      //console.log(boardCopy.gamestate);

      var subalpha = -this.buildTree_r(boardCopy, otherPlayer, depth + 1); //pass new gamestate into recursion
      if(alpha < subalpha){ //if move is better than alpha, increase alpha
        alpha = subalpha;
      }
      if(depth == 0){ //only if we are looking at REAL gamestate do we push an alpha to the list
        saList.push(subalpha);
      }
    }
    if(depth == 0){
      var posMoves = [];
      for(var n=0; n<saList.length; n++){
        if(saList[n] == alpha){
          posMoves.push(moveList[n]);
        }
      }
      this.bestMove = this.rand(posMoves); //in future pick random..
    }
    return alpha;
  },
  rand: function(list){
    return list[Math.floor(Math.random() * list.length)]; // return an item
  },
  negamax: function(board, depth, player){
  /*  === Wiki pseudo code ===
    if depth = 0 or node is a terminal node
       return player (1 or -1) * the heuristic value of node

    bestValue := −∞
    foreach child of node
      v := −negamax(child, depth − 1, −color)
      bestValue := max( bestValue, v )
      return bestValue
 
    === Code example ===
 1  const int sign[2]={1,-1}   //0 is blue, 1 is red
 2  
 3  int NegaMax(Board b, int depth, int color) {
 4      if (GameOver(b) or depth>MaxDepth)
 5          return sign[color]*Analysis(b)
 6      int max = -infinity
 7      for each legal move m in board b {
 8          copy b to c
 9          make move m in board c
10          int x= - NegaMax(c, depth+1, 1-color)  //Note the "-" before "NegaMax"
11          if (x>max) max = x
12      }
13      return max
14  }


    }*/
    if ( depth == this.MAX_DEPTH || board.isFull() ) {
      var r = player * board.score(depth);
      console.log('Value: ', r);
      return r;
    }

    var bestValue = -100;
    var moveList = board.getMoves();
    
    for(var i=0; i<moveList.length; i++){
      var boardCopy = board.copy(); //Copy current gamestate
      boardCopy.move(player, moveList[i]);
      var v = -this.negamax(boardCopy, depth + 1, -player)
      bestValue = Math.max( bestValue, v )
      //console.log(i, ' - bestValue: ', bestValue);
    }
    return bestValue;
  },
  eval: function(){
    // input: current board state
    // take all available moves, pass them to negamax and create a list of the highest scores, keep them linked to the moves
    // 
  }
}


/*
board object    which is the node in negamax function
  value         hold the value for the player at hand
  winner()      end state of the game, terminal / leaf node
  moves()       Available moves
*/

// board object
var Board = function(){
  //this.value = 3;
  this.empty = 0;
  this.X = 1;             //player x, 1st  player according to negamax 1
  this.O = -1;            // player o, 2nd player according to negamax -1
  this.wins = [
    [0,1,2],
    [3,4,5],
    [6,7,8],
    [0,3,6],
    [1,4,7],
    [2,5,8],
    [0,4,8],
    [2,4,6]
    ];
  this.gamestate = [0,0,0,0,0,0,0,0,0];
}

Board.prototype = {
  copy: function(){
    var b = new Board();
    for(var i=0; i<9; i++){
      b.gamestate[i] = this.gamestate[i];
    }
    return b;
  },
  move: function(player, pos){
    this.gamestate[pos] = player;
  },
  getMoves: function(){
    var moves = [];
    for(var i=0; i<9; i++){
      if(this.gamestate[i] == this.empty){
        moves.push(i);
      }
    }
    return moves;
  },
  isFull: function(){
    for(var i=0; i<9; i++){
      if(this.gamestate[i] == this.empty){
        return false;
      }
    }
    return true;
  },
  getWinner: function(){
    for(var i=0; i<this.wins.length; i++){
      var a, b ,c;
      a = this.gamestate[this.wins[i][0]];
      b = this.gamestate[this.wins[i][1]];
      c = this.gamestate[this.wins[i][2]];

      if(a == b && a == c && a != this.empty){
        return a;
      }
    }
    return this.empty;
  },
  score: function(depth){
    return 10 - depth;
  }
}

// experiment area with the various functions

var b = new Board();
// alternates between 0 and 8, because of rand when depth is 0. Unsure why?

//  0 1 2
//  3 4 5
//  6 7 8
//b.move('x',0);  b.move('o',1);  b.move('o',2); 
//b.move('o',3);  b.move('o',4);      /* 0 */ 
//b.move('x',6);  /* 0 */         b.move('x',8);
//player, pos

//  x   x   ?
//  o   o   ?
//  x   x   ?
// o is at play
b.move(1,0); b.move(1,1);
b.move(-1,3); b.move(-1,4);
b.move(1,6); b.move(1,7);

console.log( b.gamestate );

var cb = function(value){
  //console.log(b.gamestate);
  console.log('bestMove: ', value);
}

var mmax = new MiniMax();
var x = mmax.negamax(b, 0, -1);
console.log(x);






    </script>

  </head>
  <body>
  </body>
</html>

b.move('o',0); b.move('o',1); /* 0 */
b.move('o',3); b.move('x',4); /* 0 */
b.move('x',6); /* 0 */ /* 0 */

Negamax algoritm is anders dan de Minimax
Tree = game play
Node = game states
Root Node = where the game is currently at
Leaf node = the end of the game

The negamax search objective is to find the node score value for the player who is playing at the root node. (current game point)
